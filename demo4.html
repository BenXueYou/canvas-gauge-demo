<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D水平仪圆盘</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            min-width: 120px;
        }
        
        input[type="range"] {
            width: 200px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">
            <div>偏航角: <span id="yaw-value">0</span>°</div>
            <div>俯仰角: <span id="pitch-value">0</span>°</div>
            <div>高度: <span id="altitude-value">0</span>m</div>
        </div>
        
        <div id="controls">
            <div class="control-group">
                <label for="yaw-control">偏航角 (0-360°):</label>
                <input type="range" id="yaw-control" min="0" max="360" value="0" step="1">
            </div>
            <div class="control-group">
                <label for="pitch-control">俯仰角 (-30-30°):</label>
                <input type="range" id="pitch-control" min="-30" max="30" value="0" step="1">
            </div>
            <div class="control-group">
                <label for="altitude-control">高度变化 (0-1000m):</label>
                <input type="range" id="altitude-control" min="0" max="1000" value="0" step="10">
            </div>
        </div>
    </div>

    <script src="./dist/three.min.js"></script>
    <script src="./dist/OrbitControls.js"></script>
    <script>
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // 添加轨道控制器（用于调试，可旋转查看）
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // 设置相机位置
        camera.position.set(0, 0, 7);
        camera.lookAt(0, 0, 0);
        
        // 环境光和定向光
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // 创建固定刻度盘组
        const fixedDialGroup = new THREE.Group();
        scene.add(fixedDialGroup);
        
        // 创建旋转的水平仪组
        const horizonGroup = new THREE.Group();
        scene.add(horizonGroup);
        
        // 创建天空半球
        const skyGeometry = new THREE.SphereGeometry(5, 64, 64, 0, Math.PI * 2, 0, Math.PI);
        const skyMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x87CEEB,
            side: THREE.BackSide,
            shininess: 10
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        horizonGroup.add(sky);
        
        // 创建地面半球
        const groundGeometry = new THREE.SphereGeometry(5, 64, 64, 0, Math.PI * 2, Math.PI, Math.PI);
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x8B4513,
            side: THREE.BackSide,
            shininess: 10
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        horizonGroup.add(ground);
        
        // 创建地平线圆环
        const horizonLineGeometry = new THREE.TorusGeometry(5, 0.02, 16, 100, Math.PI * 2);
        const horizonLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const horizonLine = new THREE.Mesh(horizonLineGeometry, horizonLineMaterial);
        horizonLine.rotation.x = Math.PI / 2;
        horizonGroup.add(horizonLine);
        
        // 创建方位指示器（N, E, S, W） - 这些现在固定在固定刻度盘上
        const createHeadingIndicator = (text, angle) => {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, 128, 128);
            context.font = 'Bold 40px Arial';
            context.textAlign = 'center';
            context.fillStyle = 'white';
            context.fillText(text, 64, 80);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const geometry = new THREE.PlaneGeometry(0.8, 0.8);
            const mesh = new THREE.Mesh(geometry, material);
            
            // 将标记放置在球体表面
            const radius = 5.02;
            const radian = angle * (Math.PI / 180);
            mesh.position.x = Math.sin(radian) * radius;
            mesh.position.z = Math.cos(radian) * radius;
            mesh.position.y = 0;
            mesh.lookAt(0, 0, 0);
            
            return mesh;
        };
        
        // 添加主要方位标记到固定刻度盘
        fixedDialGroup.add(createHeadingIndicator('N', 0));
        fixedDialGroup.add(createHeadingIndicator('E', 90));
        fixedDialGroup.add(createHeadingIndicator('S', 180));
        fixedDialGroup.add(createHeadingIndicator('W', 270));
        
        // 添加次要方位标记（每45度）到固定刻度盘
        for (let angle = 45; angle < 360; angle += 45) {
            if (angle % 90 === 0) continue; // 跳过主要方位
            
            const markerGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            
            const radius = 5.02;
            const radian = angle * (Math.PI / 180);
            marker.position.x = Math.sin(radian) * radius;
            marker.position.z = Math.cos(radian) * radius;
            marker.position.y = 0;
            marker.rotation.x = Math.PI / 2;
            
            fixedDialGroup.add(marker);
        }
        
        // 创建俯仰刻度
        const createPitchScale = () => {
            const pitchGroup = new THREE.Group();
            
            // 创建刻度线
            for (let i = -30; i <= 30; i += 5) {
                if (i === 0) continue; // 跳过地平线
                
                const lineLength = i % 10 === 0 ? 0.8 : 0.4;
                const lineGeometry = new THREE.PlaneGeometry(lineLength, 0.02);
                const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                
                // 将线放置在球体内表面
                line.position.y = Math.sin(i * (Math.PI / 180)) * 5;
                const radiusAtY = Math.cos(i * (Math.PI / 180)) * 5;
                line.position.z = -radiusAtY;
                
                // 添加刻度值（每10度）
                if (i % 10 === 0) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 32;
                    const context = canvas.getContext('2d');
                    context.fillStyle = 'rgba(0, 0, 0, 0)';
                    context.fillRect(0, 0, 64, 32);
                    context.font = 'Bold 16px Arial';
                    context.textAlign = 'center';
                    context.fillStyle = 'white';
                    context.fillText(Math.abs(i).toString(), 32, 20);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const textMaterial = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    
                    const textGeometry = new THREE.PlaneGeometry(0.4, 0.2);
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    
                    textMesh.position.y = line.position.y;
                    textMesh.position.z = line.position.z;
                    textMesh.position.x = lineLength / 2 + 0.3;
                    
                    pitchGroup.add(textMesh);
                    
                    // 对称的另一侧
                    const textMesh2 = textMesh.clone();
                    textMesh2.position.x = -(lineLength / 2 + 0.3);
                    pitchGroup.add(textMesh2);
                }
                
                pitchGroup.add(line);
            }
            
            return pitchGroup;
        };
        
        const pitchScale = createPitchScale();
        horizonGroup.add(pitchScale);
        
        // 创建飞机参考标记
        const createAircraftReference = () => {
            const referenceGroup = new THREE.Group();
            
            // 水平线
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-1, 0, -0.01),
                new THREE.Vector3(-0.2, 0, -0.01),
                new THREE.Vector3(0.2, 0, -0.01),
                new THREE.Vector3(1, 0, -0.01)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            referenceGroup.add(line);
            
            // 垂直线
            const vertLineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0.2, -0.01),
                new THREE.Vector3(0, 0.5, -0.01)
            ]);
            const vertLine = new THREE.Line(vertLineGeometry, lineMaterial);
            referenceGroup.add(vertLine);
            
            // 小三角形
            const triangleShape = new THREE.Shape();
            triangleShape.moveTo(-0.1, 0.2);
            triangleShape.lineTo(0.1, 0.2);
            triangleShape.lineTo(0, 0.3);
            triangleShape.lineTo(-0.1, 0.2);
            
            const triangleGeometry = new THREE.ShapeGeometry(triangleShape);
            const triangleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
            referenceGroup.add(triangle);
            
            return referenceGroup;
        };
        
        const aircraftReference = createAircraftReference();
        scene.add(aircraftReference);
        
        // 创建外侧刻度盘和指针
        const createOuterDial = () => {
            const outerDialGroup = new THREE.Group();
            
            // 外侧刻度环
            const outerRingGeometry = new THREE.TorusGeometry(5.5, 0.02, 16, 100);
            const outerRingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
            outerRing.rotation.x = Math.PI / 2;
            outerDialGroup.add(outerRing);
            
            // 添加刻度标记（每10度）
            for (let angle = 0; angle < 360; angle += 10) {
                const tickGeometry = new THREE.BoxGeometry(0.02, angle % 30 === 0 ? 0.2 : 0.1, 0.02);
                const tickMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const tick = new THREE.Mesh(tickGeometry, tickMaterial);
                
                const radius = 5.5;
                const radian = angle * (Math.PI / 180);
                tick.position.x = Math.sin(radian) * radius;
                tick.position.z = Math.cos(radian) * radius;
                tick.position.y = 0;
                tick.rotation.y = -radian;
                
                outerDialGroup.add(tick);
                
                // 添加数字标记（每30度）
                if (angle % 30 === 0) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 32;
                    const context = canvas.getContext('2d');
                    context.fillStyle = 'rgba(0, 0, 0, 0)';
                    context.fillRect(0, 0, 64, 32);
                    context.font = 'Bold 16px Arial';
                    context.textAlign = 'center';
                    context.fillStyle = 'white';
                    context.fillText(angle.toString(), 32, 20);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const textMaterial = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    
                    const textGeometry = new THREE.PlaneGeometry(0.5, 0.25);
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    
                    textMesh.position.x = Math.sin(radian) * (radius + 0.3);
                    textMesh.position.z = Math.cos(radian) * (radius + 0.3);
                    textMesh.position.y = 0;
                    textMesh.lookAt(0, 0, 0);
                    
                    outerDialGroup.add(textMesh);
                }
            }
            
            // 创建指针
            const pointerGroup = new THREE.Group();
            
            // 指针主体
            const pointerGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0.2, 0),
                new THREE.Vector3(0, -0.2, 0),
                new THREE.Vector3(0.5, 0, 0),
                new THREE.Vector3(0, 0.2, 0)
            ]);
            const pointerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const pointer = new THREE.Mesh(pointerGeometry, pointerMaterial);
            pointer.position.z = -5.5;
            pointerGroup.add(pointer);
            
            // 指针圆点
            const pointerDotGeometry = new THREE.CircleGeometry(0.05, 16);
            const pointerDotMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const pointerDot = new THREE.Mesh(pointerDotGeometry, pointerDotMaterial);
            pointerDot.position.z = -5.5;
            pointerGroup.add(pointerDot);
            
            outerDialGroup.add(pointerGroup);
            
            return { outerDial: outerDialGroup, pointer: pointerGroup };
        };
        
        const { outerDial, pointer } = createOuterDial();
        fixedDialGroup.add(outerDial);
        scene.add(pointer);
        
        // 状态变量
        let yaw = 0;      // 偏航角 (0-360度)
        let pitch = 0;    // 俯仰角 (-30到30度)
        let altitude = 0; // 高度 (0-1000米)
        
        // 更新显示
        const updateDisplay = () => {
            // 更新水平仪旋转（仅俯仰）
            horizonGroup.rotation.x = pitch * (Math.PI / 180);
            
            // 旋转指针而不是整个刻度盘
            pointer.rotation.y = -yaw * (Math.PI / 180);
            
            // 根据高度调整俯仰角（模拟高度变化效果）
            // 这里简化处理，实际应用中可能需要更复杂的算法
            const targetPitch = altitude / 1000 * 15; // 每1000米对应15度俯仰
            pitch = THREE.MathUtils.lerp(pitch, targetPitch, 0.1);
            horizonGroup.rotation.x = pitch * (Math.PI / 180);
            
            // 更新UI显示
            document.getElementById('yaw-value').textContent = Math.round(yaw);
            document.getElementById('pitch-value').textContent = Math.round(pitch);
            document.getElementById('altitude-value').textContent = Math.round(altitude);
        };
        
        // 事件监听
        document.getElementById('yaw-control').addEventListener('input', (e) => {
            yaw = parseFloat(e.target.value);
        });
        
        document.getElementById('pitch-control').addEventListener('input', (e) => {
            pitch = parseFloat(e.target.value);
        });
        
        document.getElementById('altitude-control').addEventListener('input', (e) => {
            altitude = parseFloat(e.target.value);
        });
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // 仅用于调试
            updateDisplay();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>